332'1from abc import ABC, abstractmethod

class Dictionary(ABC):
    @abstractmethod
    def capacity(self):
        """Retorna o comprimento da tabela hash."""
        pass
    
    @abstractmethod
    def set(self, key, value):
        """Adiciona uma nova entrada ou atualiza uma entrada existente"""
        pass
    
    @abstractmethod
    def get(self, key):
        """Retorna o valor relacionado com a chave key ou None caso não exista"""
        pass
    
    @abstractmethod
    def delete(self, key):
        """Remove e retorna o valor relacionado com a chave key ou None caso não exista"""
        pass
if __name__ == "__main__":
    
    print("### INICIANDO TESTE DA TABELA DE ENDEREÇAMENTO DIRETO (DAT) ###")
    
    # 1. Inicialização
    # Criamos uma DAT com capacidade 8. Universo de chaves U = {0, 1, ..., 7}
    dat = DirectAddressTable(size=8)
    print(dat)
    print(f"1. Capacidade reportada: {dat.capacity()}")
    
    # 2. Teste de Inserção (set)
    print("\n--- 2. Testando Inserção (SET) ---")
    dat.set(5, "Dado da Chave 5")
    dat.set(2, "Dado Satélite A")
    dat.set(0, 100)
    print(dat)
    
    # 3. Teste de Atualização (set na mesma chave)
    print("\n--- 3. Testando Atualização (SET com chave existente) ---")
    dat.set(2, "Valor Atualizado B") # Deve atualizar o valor no Slot 2 [cite: 485]
    print(f"Valor no Slot 2 (após atualização): {dat.get(2)}")
    print(dat)
    
    # 4. Teste de Busca (get)
    print("\n--- 4. Testando Busca (GET) ---")
    print(f"Busca Chave 5: {dat.get(5)}")
    print(f"Busca Chave 1 (vazia): {dat.get(1)}") # Slot vazio deve retornar None
    
    # 5. Teste de Deleção (delete)
    print("\n--- 5. Testando Deleção (DELETE) ---")
    valor_removido = dat.delete(0)
    print(f"Valor removido da Chave 0: {valor_removido}")
    print(f"Busca Chave 0 após remoção: {dat.get(0)}") # Deve retornar None
    print(dat)
    
    # 6. Teste de Chaves Inválidas (Restrições da DAT)
    print("\n--- 6. Testando Chaves Inválidas ---")
    # Chave fora do limite superior (key >= size)
    dat.set(8, "Chave 8 (Inválida)") 
    # Chave negativa
    dat.set(-1, "Chave -1 (Inválida)")
    # Tentativa de busca de chave inválida
    print(f"Busca Chave 8: {dat.get(8)}") 
    print(f"Busca Chave -1: {dat.get(-1)}") 
class Entry:
    """Classe para guardar a chave e o dado satélite (valor)."""
    def __init__(self, key, value):
        self.key = key
        self.value = value

    def __repr__(self):
        return f"Entry({self.key}: {self.value})"

class DirectAddressTable(Dictionary):
    
    def __init__(self, size):
        self._size = size
        self._table = [None] * size

    def capacity(self):
        """Retorna o comprimento (tamanho) da tabela."""
        return self._size

    def _validate_key(self, key):
        """Verifica se a chave é um índice válido para a DAT (inteiro >= 0 e < size)."""
        if not isinstance(key, int) or key < 0 or key >= self._size:
            raise ValueError(
                f"Chave '{key}' inválida. Deve ser um inteiro não negativo no intervalo [0, {self._size - 1}]."
            )
        
    def set(self, key, value):
        """Adiciona ou atualiza um par (key, value). Operação O(1)[cite: 488, 491]."""
        try:
            self._validate_key(key)
        except ValueError as e:
            print(f"ERRO DE INSERÇÃO: {e}")
            return

        if self._table[key] is not None:
            self._table[key].value = value # Atualização
        else:
            self._table[key] = Entry(key, value) # Inserção

    def get(self, key):
        """Retorna o valor em T[key] ou None. Operação O(1)[cite: 488, 489, 490]."""
        if not isinstance(key, int) or key < 0 or key >= self._size:
            return None 

        entry = self._table[key]
        if entry is not None:
            return entry.value
        
        return None
    def delete(self, key):
        """Remove e retorna o valor em T[key] ou None. Operação O(1)[cite: 488, 492, 493, 494]."""
        if not isinstance(key, int) or key < 0 or key >= self._size:
            return None

        entry = self._table[key]
        if entry is not None:
            deleted_value = entry.value
            self._table[key] = None # Atribui nulo (nil) para remoção [cite: 486]
            return deleted_value
        
        return None

    def __repr__(self):
        """Visualização da DAT."""
        entries = [f"Slot {i}: {e.value}" for i, e in enumerate(self._table) if e is not None]
        status = ", ".join(entries) if entries else "Vazia"
        return f"\nDAT (Capacidade: {self._size})\n--- Conteúdo: {status} ---\n"
    dat.set(-1, "Chave -1 (Inválida)")
    # Tentativa de busca de chave inválida
    print(f"Busca Chave 8: {dat.get(8)}") 
    print(f"Busca Chave -1: {dat.get(-1)}") 
